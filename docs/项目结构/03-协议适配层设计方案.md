# 协议适配层设计方案

## 1. 设计目标

1. **最小化 UI 改动** - 新协议切换时，UI 层代码基本不需要修改
2. **最小化 Service 改动** - useWebHID 核心逻辑保持稳定
3. **易于扩展** - 添加新协议只需创建协议文件并注册
4. **类型安全** - 完整的 TypeScript 类型支持
5. **向后兼容** - 支持多协议共存

## 2. 架构设计

### 2.1 分层架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                         UI 层                                    │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │  组件只依赖 useWebHID 提供的统一接口                        │   │
│  │  通过 protocol.features 动态适配 UI 显示                   │   │
│  └──────────────────────────────────────────────────────────┘   │
│                              │                                   │
│                              ▼                                   │
├─────────────────────────────────────────────────────────────────┤
│                       Service 层                                 │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                    useWebHID.ts                           │   │
│  │  ┌─────────────────────────────────────────────────────┐ │   │
│  │  │ 协议无关的通用逻辑:                                   │ │   │
│  │  │ - 设备连接/断开                                       │ │   │
│  │  │ - 命令发送/响应接收                                   │ │   │
│  │  │ - 状态管理                                           │ │   │
│  │  └─────────────────────────────────────────────────────┘ │   │
│  │  ┌─────────────────────────────────────────────────────┐ │   │
│  │  │ 协议适配层:                                          │ │   │
│  │  │ - currentProtocol.commands.xxx()  // 命令编码        │ │   │
│  │  │ - currentProtocol.parsers.xxx()   // 响应解析        │ │   │
│  │  │ - currentProtocol.features        // 特性查询        │ │   │
│  │  └─────────────────────────────────────────────────────┘ │   │
│  └──────────────────────────────────────────────────────────┘   │
│                              │                                   │
│                              ▼                                   │
├─────────────────────────────────────────────────────────────────┤
│                       Protocol 层                                │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │                    协议注册中心 (registry.ts)               │ │
│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐       │ │
│  │  │ YHH协议 │  │ 新协议A │  │ 新协议B │  │ 通用协议 │       │ │
│  │  │ yhh.ts  │  │ xxx.ts  │  │ yyy.ts  │  │generic.ts│       │ │
│  │  └─────────┘  └─────────┘  └─────────┘  └─────────┘       │ │
│  │       ↓            ↓            ↓            ↓             │ │
│  │  ┌─────────────────────────────────────────────────────┐  │ │
│  │  │              DeviceProtocol 接口                     │  │ │
│  │  │  - identify()   设备识别                             │  │ │
│  │  │  - commands     命令定义                             │  │ │
│  │  │  - parsers      响应解析                             │  │ │
│  │  │  - features     设备特性                             │  │ │
│  │  └─────────────────────────────────────────────────────┘  │ │
│  └────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 协议检测流程

```
设备连接
    │
    ▼
┌─────────────────────┐
│ navigator.hid.      │
│ requestDevice()     │
└─────────┬───────────┘
          │
          ▼
┌─────────────────────┐
│ detectProtocol()    │
│ 遍历 protocolRegistry│
└─────────┬───────────┘
          │
          ▼
┌─────────────────────┐     ┌─────────────────────┐
│ protocol.identify() │────▶│ 返回 true?          │
│ 检查 VID/PID/名称   │     │                     │
└─────────────────────┘     └─────────┬───────────┘
                                      │
                    ┌─────────────────┴─────────────────┐
                    │                                   │
                    ▼                                   ▼
          ┌─────────────────┐               ┌─────────────────┐
          │ 使用匹配的协议   │               │ 继续检查下一个   │
          │ currentProtocol │               │ 协议             │
          └─────────────────┘               └─────────────────┘
```

## 3. 接口设计

### 3.1 核心协议接口 (增强版)

```typescript
// src/renderer/src/protocols/index.ts

/**
 * 设备协议接口 - 所有协议必须实现此接口
 */
export interface DeviceProtocol {
  /** 协议名称 (用于日志和调试) */
  name: string

  /** 协议版本 */
  version?: string

  /**
   * 设备识别函数
   * @param device HID 设备对象
   * @returns 是否匹配此协议
   */
  identify: (device: HIDDevice) => boolean

  /**
   * 协议配置 (可选)
   * 用于配置协议特定的行为
   */
  config?: ProtocolConfig

  /**
   * 命令定义
   * 包含所有设备命令的编码方法
   */
  commands: ProtocolCommands

  /**
   * 响应解析器
   * 包含所有设备响应的解析方法
   */
  parsers: ProtocolParsers

  /**
   * 报文识别器 (可选)
   * 用于识别设备主动上报的数据
   */
  reporters?: ProtocolReporters

  /**
   * 设备特性配置
   * 声明设备支持的功能和参数范围
   */
  features?: DeviceFeatures
}

/**
 * 协议配置
 */
export interface ProtocolConfig {
  /** 发送包头 (如 0x55) */
  sendHeader?: number
  /** 接收包头 (如 0xAA) */
  receiveHeader?: number
  /** Report ID */
  reportId?: number
  /** 数据包长度 */
  packetLength?: number
  /** 命令超时时间 (ms) */
  commandTimeout?: number
  /** 命令重试次数 */
  commandRetries?: number
}

/**
 * 命令定义接口
 */
export interface ProtocolCommands {
  // ===== 查询命令 (返回固定数组) =====
  /** 获取设备信息 */
  getDeviceInfo: number[]
  /** 获取电池状态 */
  getBattery: number[]
  /** 获取回报率 */
  getReportRate: number[]
  /** 获取 DPI */
  getDPI: number[]
  /** 获取背光配置 */
  getBacklight: number[]
  /** 获取按键映射 */
  getButtonMapping: number[]
  /** 获取滚轮方向 (可选) */
  getScrollDirection?: number[]
  /** 获取宏列表 (可选) */
  getMacroList?: number[]
  /** 获取宏数据 (可选) */
  getMacroData?: (macroIndex: number) => number[]

  // ===== 设置命令 (返回动态数组) =====
  /** 设置回报率 */
  setReportRate: (rate: number, context?: CommandContext) => number[]
  /** 设置 DPI */
  setDPI: (level: number, value: number, context?: CommandContext) => number[]
  /** 设置背光模式 */
  setBacklightMode: (mode: number) => number[]
  /** 设置背光亮度 */
  setBacklightBrightness: (brightness: number) => number[]
  /** 设置背光频率 */
  setBacklightFrequency: (frequency: number) => number[]
  /** 设置背光颜色 */
  setBacklightColor: (r: number, g: number, b: number) => number[]
  /** 设置滚轮方向 (可选) */
  setScrollDirection?: (direction: number, context?: CommandContext) => number[]
  /** 设置按键映射 (可选) */
  setButtonMapping?: (buttonMappings: number[][]) => number[]
  /** 设置宏 (可选) */
  setMacro?: (macroIndex: number, macroEvents: number[]) => number[]
  /** 删除宏 (可选) */
  deleteMacro?: (macroIndex: number) => number[]
}

/**
 * 命令上下文
 * 用于传递当前设备状态，避免命令之间的耦合
 */
export interface CommandContext {
  /** 当前 DPI 档位 */
  dpiLevel?: number
  /** 当前回报率索引 */
  reportRateIndex?: number
  /** 当前滚轮方向 */
  scrollDirection?: number
  /** 其他扩展字段 */
  [key: string]: any
}

/**
 * 响应解析器接口
 */
export interface ProtocolParsers {
  /** 解析设备信息 */
  deviceInfo: (response: Uint8Array) => DeviceInfoResult
  /** 解析电池电量 */
  battery: (response: Uint8Array) => number
  /** 解析回报率 */
  reportRate: (response: Uint8Array) => number
  /** 解析 DPI */
  dpi: (response: Uint8Array) => DPIResult
  /** 解析背光配置 */
  backlight: (response: Uint8Array) => number
  /** 解析按键映射 */
  buttonMapping: (response: Uint8Array) => ButtonMappingResult[]
  /** 解析滚轮方向 (可选) */
  scrollDirection?: (response: Uint8Array) => number
  /** 解析宏列表 (可选) */
  macroList?: (response: Uint8Array) => MacroListResult[]
  /** 解析宏数据 (可选) */
  macroData?: (response: Uint8Array) => MacroEventResult[]
  /** 解析 DPI 变化通知 (可选) */
  dpiChange?: (response: Uint8Array) => DPIResult | null
}

/**
 * 报文识别器接口
 */
export interface ProtocolReporters {
  /** 判断是否为有效响应 */
  isValidResponse?: (response: Uint8Array) => boolean
  /** 判断是否为 DPI 变化通知 */
  isDPIChangeReport?: (response: Uint8Array) => boolean
  /** 判断是否为电池状态通知 */
  isBatteryReport?: (response: Uint8Array) => boolean
}

/**
 * 设备特性配置
 */
export interface DeviceFeatures {
  /** 支持的 DPI 档位列表 */
  supportedDPI?: number[]
  /** 最大 DPI 档位数 */
  maxDPILevels?: number
  /** 支持的回报率列表 */
  supportedReportRates?: number[]
  /** 按键数量 */
  buttonCount?: number
  /** 是否支持 RGB 背光 */
  hasRGB?: boolean
  /** 是否有电池 */
  hasBattery?: boolean
  /** 是否支持板载内存 */
  hasOnboardMemory?: boolean
  /** 是否支持滚轮方向设置 */
  hasScrollDirection?: boolean
  /** 是否支持宏功能 */
  hasMacro?: boolean
  /** 最大宏数量 */
  maxMacroCount?: number
  /** 是否支持双模式 (USB + 2.4G) */
  supportsDualMode?: boolean
  /** 按键索引映射 (UI索引 → 设备索引) */
  buttonIndexMapping?: number[]
}

// ===== 结果类型定义 =====

export interface DeviceInfoResult {
  name: string
  model: string
  firmwareVersion: string
}

export interface DPIResult {
  value: number
  level: number
  reportRate?: number
}

export interface ButtonMappingResult {
  index: number
  code: number
  modifier: number
  extra: number
}

export interface MacroListResult {
  index: number
  hasData: boolean
}

export interface MacroEventResult {
  delay: number
  eventType: number
  keyCode: number
}
```

### 3.2 协议注册中心 (增强版)

```typescript
// src/renderer/src/protocols/registry.ts

import { DeviceProtocol } from './index'
import { genericProtocol } from './generic'
import { yhhProtocol } from './yhh'
// import { newMouseProtocol } from './newMouse'  // 新协议

/**
 * 协议注册表
 * 按优先级排序，越靠前优先级越高
 * genericProtocol 必须放在最后作为默认协议
 */
export const protocolRegistry: DeviceProtocol[] = [
  // newMouseProtocol,  // 新协议 (优先级最高)
  yhhProtocol,          // YHH 协议
  genericProtocol       // 通用协议 (默认)
]

/**
 * 检测设备协议
 * @param device HID 设备
 * @returns 匹配的协议
 */
export function detectProtocol(device: HIDDevice): DeviceProtocol {
  for (const protocol of protocolRegistry) {
    if (protocol.identify(device)) {
      console.log(`[协议检测] 匹配协议: ${protocol.name}`)
      return protocol
    }
  }
  console.log('[协议检测] 使用默认协议: Generic')
  return genericProtocol
}

/**
 * 根据名称获取协议
 * @param name 协议名称
 * @returns 协议对象或 undefined
 */
export function getProtocolByName(name: string): DeviceProtocol | undefined {
  return protocolRegistry.find(p => p.name === name)
}

/**
 * 获取所有已注册的协议名称
 * @returns 协议名称列表
 */
export function getRegisteredProtocols(): string[] {
  return protocolRegistry.map(p => p.name)
}
```

### 3.3 新协议模板

```typescript
// src/renderer/src/protocols/newMouse.ts

import { DeviceProtocol, CommandContext } from './index'

/**
 * 新鼠标协议
 * 设备信息: VID: xxxx, PID: xxxx
 *
 * 协议特征:
 * - 发送包头: 0x??
 * - 接收包头: 0x??
 * - ReportID: ?
 * - 数据长度: ?? 字节
 */
export const newMouseProtocol: DeviceProtocol = {
  name: 'New Mouse',
  version: '1.0.0',

  // ===== 设备识别 =====
  identify: (device: HIDDevice) => {
    // 方式1: 通过 VID/PID 识别
    if (device.vendorId === 0xXXXX && device.productId === 0xXXXX) {
      return true
    }
    // 方式2: 通过产品名称识别
    const productName = device.productName?.toLowerCase() || ''
    return productName.includes('new mouse')
  },

  // ===== 协议配置 =====
  config: {
    sendHeader: 0x00,      // 发送包头
    receiveHeader: 0x00,   // 接收包头
    reportId: 0,           // Report ID
    packetLength: 64,      // 数据包长度
    commandTimeout: 1000,  // 命令超时
    commandRetries: 3      // 重试次数
  },

  // ===== 命令定义 =====
  commands: {
    // 查询命令
    getDeviceInfo: [/* 命令字节 */],
    getBattery: [/* 命令字节 */],
    getReportRate: [/* 命令字节 */],
    getDPI: [/* 命令字节 */],
    getBacklight: [/* 命令字节 */],
    getButtonMapping: [/* 命令字节 */],

    // 设置命令
    setReportRate: (rate: number, context?: CommandContext) => {
      // 根据协议文档实现命令编码
      return [/* 命令字节 */]
    },

    setDPI: (level: number, value: number, context?: CommandContext) => {
      // 根据协议文档实现命令编码
      return [/* 命令字节 */]
    },

    setBacklightMode: (mode: number) => [/* 命令字节 */],
    setBacklightBrightness: (brightness: number) => [/* 命令字节 */],
    setBacklightFrequency: (frequency: number) => [/* 命令字节 */],
    setBacklightColor: (r: number, g: number, b: number) => [/* 命令字节 */],

    // 可选命令
    setScrollDirection: (direction: number, context?: CommandContext) => {
      return [/* 命令字节 */]
    },

    setButtonMapping: (buttonMappings: number[][]) => {
      return [/* 命令字节 */]
    }
  },

  // ===== 响应解析 =====
  parsers: {
    deviceInfo: (response: Uint8Array) => {
      // 根据协议文档解析响应
      return {
        name: '设备名称',
        model: '型号',
        firmwareVersion: '版本'
      }
    },

    battery: (response: Uint8Array) => {
      // 返回电池百分比 0-100
      return response[0] || 0
    },

    reportRate: (response: Uint8Array) => {
      // 返回回报率 Hz
      return 1000
    },

    dpi: (response: Uint8Array) => {
      // 返回 DPI 信息
      return {
        value: 1600,
        level: 1,
        reportRate: 4
      }
    },

    backlight: (response: Uint8Array) => {
      // 返回背光模式
      return response[0] || 0
    },

    buttonMapping: (response: Uint8Array) => {
      // 返回按键映射数组
      return []
    }
  },

  // ===== 报文识别器 =====
  reporters: {
    isValidResponse: (response: Uint8Array) => {
      // 检查响应是否有效
      return response.length > 0 && response[0] === 0x00 // 根据协议修改
    },

    isDPIChangeReport: (response: Uint8Array) => {
      // 检查是否为 DPI 变化通知
      return false
    }
  },

  // ===== 设备特性 =====
  features: {
    supportedDPI: [800, 1600, 3200, 6400],
    maxDPILevels: 4,
    supportedReportRates: [125, 250, 500, 1000],
    buttonCount: 6,
    hasRGB: true,
    hasBattery: false,
    hasOnboardMemory: true,
    hasScrollDirection: false,
    hasMacro: false,
    maxMacroCount: 0,
    supportsDualMode: false,
    buttonIndexMapping: [0, 1, 2, 3, 4, 5]  // UI索引 → 设备索引
  }
}
```

## 4. Service 层适配

### 4.1 useWebHID 改进建议

```typescript
// src/renderer/src/composables/useWebHID.ts

// 改进1: 使用协议配置的响应包头
function waitForResponse(timeout = 1000): Promise<Uint8Array | null> {
  return new Promise((resolve) => {
    const handler = (event: HIDInputReportEvent) => {
      const data = new Uint8Array(event.data.byteLength)
      for (let i = 0; i < event.data.byteLength; i++) {
        data[i] = event.data.getUint8(i)
      }

      // 使用协议配置的响应验证
      const protocol = currentProtocol.value
      if (protocol?.reporters?.isValidResponse) {
        if (!protocol.reporters.isValidResponse(data)) {
          return // 忽略无效响应
        }
      } else {
        // 默认行为: 检查 0xAA 包头 (向后兼容)
        if (data[0] !== 0xaa) {
          return
        }
      }

      // ... 处理有效响应
    }
    // ...
  })
}

// 改进2: 使用 CommandContext 传递状态
async function setReportRate(rate: number): Promise<Result> {
  if (!device || !currentProtocol.value) return { success: false, message: '设备未连接' }

  const context: CommandContext = {
    dpiLevel: deviceStatus.value.dpiLevel,
    reportRateIndex: deviceStatus.value.reportRateIndex,
    scrollDirection: deviceStatus.value.scrollDirection
  }

  const command = currentProtocol.value.commands.setReportRate(rate, context)
  // ...
}

// 改进3: 使用协议特性配置按键索引映射
function getButtonIndexMapping(): number[] {
  return currentProtocol.value?.features?.buttonIndexMapping || [0, 1, 2, 3, 4, 5, 6, 7]
}
```

## 5. UI 层适配

### 5.1 ButtonMapping 组件改进

```typescript
// src/renderer/src/components/ButtonMapping.vue

// 改进: 从协议特性获取按键索引映射
const uiToDeviceIndex = computed(() => {
  const protocol = getCurrentProtocol()
  return protocol?.features?.buttonIndexMapping || [0, 1, 2, 3, 4, 5, 6, 7]
})

// 改进: 从协议特性获取按键数量
const buttonCount = computed(() => {
  const protocol = getCurrentProtocol()
  return protocol?.features?.buttonCount || 8
})
```

## 6. 新协议对接步骤

### 6.1 快速对接流程

```
1. 创建协议文件
   └── src/renderer/src/protocols/newMouse.ts

2. 实现 DeviceProtocol 接口
   ├── identify()     - 设备识别
   ├── commands       - 命令编码
   ├── parsers        - 响应解析
   └── features       - 特性配置

3. 注册协议
   └── src/renderer/src/protocols/registry.ts
       └── 添加到 protocolRegistry 数组

4. 测试验证
   ├── 设备连接
   ├── 功能测试
   └── 边界测试
```

### 6.2 详细步骤

#### 步骤 1: 创建协议文件

```bash
# 复制模板
cp src/renderer/src/protocols/yhh.ts src/renderer/src/protocols/newMouse.ts
```

#### 步骤 2: 实现设备识别

```typescript
identify: (device: HIDDevice) => {
  // 根据新设备的 VID/PID 或产品名称实现
  return device.vendorId === 0xXXXX && device.productId === 0xXXXX
}
```

#### 步骤 3: 实现命令编码

根据协议文档，实现各个命令的字节编码。

#### 步骤 4: 实现响应解析

根据协议文档，实现各个响应的解析逻辑。

#### 步骤 5: 配置设备特性

```typescript
features: {
  supportedDPI: [/* 根据设备支持的 DPI 档位 */],
  supportedReportRates: [/* 根据设备支持的回报率 */],
  buttonCount: /* 按键数量 */,
  // ... 其他特性
}
```

#### 步骤 6: 注册协议

```typescript
// registry.ts
import { newMouseProtocol } from './newMouse'

export const protocolRegistry: DeviceProtocol[] = [
  newMouseProtocol,  // 新协议
  yhhProtocol,
  genericProtocol
]
```

## 7. 最佳实践

### 7.1 协议实现建议

1. **命令编码**
   - 使用常量定义命令字节，提高可读性
   - 添加详细注释说明每个字节的含义
   - 使用辅助函数处理复杂的编码逻辑

2. **响应解析**
   - 添加数据长度检查，避免越界访问
   - 处理异常情况，返回合理的默认值
   - 记录解析日志，便于调试

3. **特性配置**
   - 准确声明设备支持的功能
   - 使用 `undefined` 表示不支持的功能
   - 提供合理的默认值

### 7.2 测试建议

1. **单元测试**
   - 测试命令编码的正确性
   - 测试响应解析的正确性
   - 测试边界条件

2. **集成测试**
   - 测试设备连接流程
   - 测试各功能的完整流程
   - 测试错误处理

3. **兼容性测试**
   - 测试多协议共存
   - 测试协议切换
   - 测试默认协议回退

## 8. 常见问题

### Q1: 新协议的响应包头不是 0xAA 怎么办？

实现 `reporters.isValidResponse()` 方法，自定义响应验证逻辑。

### Q2: 新设备的按键数量不同怎么办？

在 `features.buttonCount` 中配置按键数量，UI 会自动适配。

### Q3: 新设备的按键索引映射不同怎么办？

在 `features.buttonIndexMapping` 中配置映射关系。

### Q4: 新设备不支持某些功能怎么办？

在 `features` 中将对应功能设为 `false` 或 `undefined`，UI 会自动隐藏相关设置。
